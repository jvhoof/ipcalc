# Azure VNET Deployment Test Workflow

## Overview

This GitHub Actions workflow (`azure-vnet-test.yml`) automatically deploys, validates, and cleans up Azure Virtual Networks (VNETs) and subnets. It supports two deployment methods:

1. **ARM Template Deployment** - Uses Azure Resource Manager templates generated by ipcalc CLI
2. **Azure CLI Deployment** - Uses Azure CLI scripts generated by ipcalc CLI

## Features

- **Dynamic Template Generation** - Uses ipcalc CLI to generate ARM templates and CLI scripts on-the-fly
- **Configurable Parameters** - CIDR blocks, subnet counts, regions, and resource naming
- **Comprehensive Validation** - Verifies VNET and subnet deployment correctness
- **Detailed Test Reports** - GitHub Actions summary with deployment results
- **Automatic Cleanup** - Removes all resources after testing to prevent charges
- **Multiple Trigger Options** - Manual workflow dispatch or automatic on pull requests

## Prerequisites

### 1. Azure Credentials Setup

You need to create an Azure Service Principal and store its credentials in GitHub Secrets.

1. **Create a Service Principal:**

```bash
az ad sp create-for-rbac \
  --name "github-actions-ipcalc" \
  --role contributor \
  --scopes /subscriptions/{subscription-id} \
  --sdk-auth
```

2. **Store the output JSON in GitHub Secrets:**
   - Go to your repository settings
   - Navigate to **Secrets and variables** → **Actions**
   - Create a new secret named `AZURE_CREDENTIALS`
   - Paste the entire JSON output from the previous command

The JSON should look like this:
```json
{
  "clientId": "<GUID>",
  "clientSecret": "<STRING>",
  "subscriptionId": "<GUID>",
  "tenantId": "<GUID>",
  "activeDirectoryEndpointUrl": "https://login.microsoftonline.com",
  "resourceManagerEndpointUrl": "https://management.azure.com/",
  "activeDirectoryGraphResourceId": "https://graph.windows.net/",
  "sqlManagementEndpointUrl": "https://management.core.windows.net:8443/",
  "galleryEndpointUrl": "https://gallery.azure.com/",
  "managementEndpointUrl": "https://management.core.windows.net/"
}
```

### 2. Environment Variables (Optional)

You can configure default values using GitHub repository variables. These will be used when the workflow is triggered automatically (on push/PR) or when workflow_dispatch inputs are not provided.

**To set repository variables:**

1. Go to your repository settings
2. Navigate to **Secrets and variables** → **Actions** → **Variables** tab
3. Click **New repository variable**
4. Add any of the following variables:

| Variable Name | Description | Default if not set |
|--------------|-------------|-------------------|
| `AZURE_DEPLOYMENT_METHOD` | Deployment method: `arm-template` or `azure-cli` | `arm-template` |
| `AZURE_RESOURCE_PREFIX` | Prefix for Azure resource names | `ipcalc-test` |
| `AZURE_LOCATION` | Azure region (e.g., `eastus`, `westus2`) | `eastus` |
| `AZURE_VNET_CIDR` | VNET CIDR block (e.g., `10.0.0.0/16`) | `10.0.0.0/16` |
| `AZURE_SUBNET_COUNT` | Number of subnets to create (1-256) | `2` |

**Precedence Order:**

The workflow uses the following precedence (highest to lowest):

1. **Manual workflow_dispatch inputs** (when you run the workflow manually)
2. **Repository variables** (configured in Settings → Variables)
3. **Hard-coded defaults** (built into the workflow)

**Example Configuration:**

For a production setup, you might set:
```
AZURE_DEPLOYMENT_METHOD = arm-template
AZURE_RESOURCE_PREFIX = myapp-test
AZURE_LOCATION = westeurope
AZURE_VNET_CIDR = 172.16.0.0/16
AZURE_SUBNET_COUNT = 4
```

This way, automatic triggers (push to beta branch, PR changes) will use these values, but you can still override them when running manually.

## Usage

### Manual Trigger (Recommended for Testing)

1. Go to **Actions** tab in your GitHub repository
2. Select **Azure VNET Deployment Test** workflow
3. Click **Run workflow**
4. Configure parameters:
   - **Deployment method**: Choose `arm-template` or `azure-cli`
   - **Resource prefix**: Custom prefix for resource names (default: `ipcalc-qa`)
   - **Location**: Azure region (default: `eastus`)
   - **VNET CIDR**: IP address range (default: `10.0.0.0/16`)
   - **Subnet count**: Number of subnets to create (default: `2`)
5. Click **Run workflow**

### Automatic Trigger

The workflow automatically runs on pull requests that modify:
- `src/templates/azure/**` files
- `.github/workflows/azure-vnet-test.yml`

## Workflow Details

### Job 1: ARM Template Deployment

**Steps:**
1. **Checkout code** - Gets repository code
2. **Setup Node.js** - Installs Node.js 20 with npm caching
3. **Install Dependencies** - Runs `npm ci` to install ipcalc dependencies
4. **Generate ARM Template using ipcalc CLI** - Uses the ipcalc CLI tool to dynamically generate an ARM template:
   ```bash
   npm run cli -- --provider azure --cidr <CIDR> --subnets <COUNT> --output arm --file template.json
   ```
5. **Azure Login** - Authenticates with Azure using service principal
6. **Create Resource Group** - Creates a resource group for testing
7. **Deploy ARM Template** - Deploys the generated VNET using ARM template
8. **Validate Deployment** - Runs comprehensive validation:
   - Verifies VNET exists
   - Validates VNET CIDR matches expected value
   - Lists and validates all subnets
   - Checks subnet provisioning states
9. **Generate Test Report** - Creates detailed report in Actions summary
10. **Cleanup Resources** - Deletes all created resources

### Job 2: Azure CLI Deployment

**Steps:**
1. **Checkout code** - Gets repository code
2. **Setup Node.js** - Installs Node.js 20 with npm caching
3. **Install Dependencies** - Runs `npm ci` to install ipcalc dependencies
4. **Generate Azure CLI Script using ipcalc CLI** - Uses the ipcalc CLI tool to generate a deployment script:
   ```bash
   npm run cli -- --provider azure --cidr <CIDR> --subnets <COUNT> --output cli --file deploy.sh
   ```
5. **Azure Login** - Authenticates with Azure
6. **Execute Azure CLI Deployment** - Runs the generated script to create resources
7. **Validate Deployment** - Same validation as ARM template job
8. **Generate Test Report** - Creates detailed report
9. **Cleanup Resources** - Deletes all created resources

## Validation Checks

The workflow performs the following validations:

✅ **VNET Existence Check**
- Verifies the VNET was created successfully

✅ **VNET CIDR Validation**
- Confirms the address space matches the specified CIDR

✅ **Subnet Discovery**
- Lists all subnets and their address prefixes

✅ **Subnet Count Validation**
- Ensures at least one subnet exists

✅ **Provisioning State Check**
- Verifies all subnets have `Succeeded` provisioning state

✅ **Resource Listing**
- Documents all deployed resources in the test report

## Test Report

After each run, a comprehensive test report is generated in the GitHub Actions summary, including:

- Deployment method used
- Timestamp
- Resource group and location
- VNET name and CIDR
- Validation status (PASSED/FAILED)
- List of deployed resources

## Resource Cleanup

The workflow **always** runs the cleanup step (even if deployment or validation fails) to ensure:

- No orphaned resources remain in Azure
- No unexpected Azure costs
- Clean state for next test run

The cleanup uses `--no-wait` flag, so it completes quickly while Azure deletes resources in the background.

## How It Works: ipcalc CLI Integration

### Dynamic Template Generation

The workflow uses the **ipcalc CLI tool** to dynamically generate Azure infrastructure code based on your specifications. This approach has several advantages:

1. **Always Up-to-Date** - Templates are generated from the latest code in your repository
2. **Flexible Configuration** - Easily test different CIDR blocks and subnet counts
3. **Validation of CLI Tool** - Tests the actual CLI tool that users will run
4. **No Manual Template Maintenance** - Templates are generated automatically

### How the CLI Generation Works

**For ARM Templates:**
```bash
npm run cli -- \
  --provider azure \
  --cidr 10.0.0.0/16 \
  --subnets 2 \
  --output arm \
  --file /tmp/test-arm-template.json
```

This generates a complete ARM template with:
- Virtual Network resource definition
- Properly calculated subnet CIDR blocks
- Azure-compliant resource naming
- Correct API versions and properties

**For Azure CLI Scripts:**
```bash
npm run cli -- \
  --provider azure \
  --cidr 10.0.0.0/16 \
  --subnets 2 \
  --output cli \
  --file /tmp/deploy-vnet.sh
```

This generates a complete bash script with:
- Resource group creation
- VNET creation with proper CIDR
- Subnet creation commands for each calculated subnet
- Proper error handling and output

### Testing Different Scenarios

You can easily test different scenarios by changing the workflow inputs:

**Small VNET with few subnets:**
- CIDR: `10.0.0.0/24`
- Subnets: `2`

**Large VNET with many subnets:**
- CIDR: `10.0.0.0/16`
- Subnets: `8`

**Custom CIDR ranges:**
- CIDR: `172.16.0.0/12`
- Subnets: `4`

The ipcalc CLI will automatically calculate the proper subnet sizes and address ranges for each scenario.

## Customization

### Testing with Different Subnet Counts

Simply adjust the `subnet_count` parameter when manually triggering the workflow. The ipcalc CLI will automatically calculate appropriate subnet sizes based on the VNET CIDR and number of subnets requested.

### Testing with Different CIDR Blocks

You can test any valid Azure VNET CIDR block:
- Minimum: `/29` (8 IP addresses)
- Maximum: `/8` (16,777,216 IP addresses)
- Common ranges: `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`

### Modifying the Workflow

To customize the workflow behavior:

1. **Change default values** - Edit the `inputs` section in the workflow file
2. **Add more validation** - Add steps to the `Validate Deployment` section
3. **Test different regions** - Add more location options or change the default
4. **Extended testing** - Add steps to test connectivity, NSGs, or other features

## Troubleshooting

### Authentication Errors

**Problem:** `ERROR: AADSTS700016: Application not found`

**Solution:** Verify your `AZURE_CREDENTIALS` secret is correctly formatted and the service principal exists.

### Resource Already Exists

**Problem:** Resource group or VNET already exists

**Solution:** The workflow uses unique names with run IDs. If you manually stopped a previous run, you may need to manually delete the resource group:

```bash
az group delete --name ipcalc-test-rg --yes
```

### Validation Failures

**Problem:** VNET or subnets not found during validation

**Solution:**
- Check Azure quota limits in your subscription
- Verify the region supports VNETs
- Check service principal has proper permissions

### Cleanup Doesn't Run

**Problem:** Resources remain after workflow completion

**Solution:** The cleanup step uses `if: always()` so it should always run. If resources remain, manually delete:

```bash
az group delete --name <resource-group-name> --yes
```

## Cost Considerations

- Basic VNET resources are typically **free** or very low cost
- Testing should cost less than $0.01 per run
- Resources are automatically cleaned up to prevent ongoing charges
- Use manual trigger to control when tests run

## Security Best Practices

1. **Least Privilege**: Service principal should only have Contributor role on specific resource groups if possible
2. **Credential Rotation**: Regularly rotate the service principal secret
3. **Branch Protection**: Limit who can trigger the workflow on your main branch
4. **Review Logs**: Regularly review workflow logs for suspicious activity

## Future Enhancements

Possible improvements to this workflow:

- [ ] Add support for NSG (Network Security Group) testing
- [ ] Test VNet peering scenarios
- [ ] Validate DNS settings
- [ ] Add cost estimation step
- [ ] Parallel testing of multiple regions
- [ ] Integration with Terraform/Bicep templates
- [ ] Slack/Teams notifications on failure

## Support

For issues or questions:
- Check GitHub Actions logs for detailed error messages
- Review Azure Activity Logs in Azure Portal
- Open an issue in the repository
